<!DOCTYPE HTML>
<!-- NewPage -->
<html lang="en">
<head>
<!-- Generated by javadoc -->
<title>TestUtils</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<link rel="stylesheet" type="text/css" href="../../stylesheet.css" title="Style">
<link rel="stylesheet" type="text/css" href="../../jquery/jquery-ui.css" title="Style">
<script type="text/javascript" src="../../script.js"></script>
<script type="text/javascript" src="../../jquery/jszip/dist/jszip.min.js"></script>
<script type="text/javascript" src="../../jquery/jszip-utils/dist/jszip-utils.min.js"></script>
<!--[if IE]>
<script type="text/javascript" src="../../jquery/jszip-utils/dist/jszip-utils-ie.min.js"></script>
<![endif]-->
<script type="text/javascript" src="../../jquery/jquery-3.3.1.js"></script>
<script type="text/javascript" src="../../jquery/jquery-migrate-3.0.1.js"></script>
<script type="text/javascript" src="../../jquery/jquery-ui.js"></script>
</head>
<body>
<script type="text/javascript"><!--
    try {
        if (location.href.indexOf('is-external=true') == -1) {
            parent.document.title="TestUtils";
        }
    }
    catch(err) {
    }
//-->
var data = {"i0":9,"i1":9,"i2":9,"i3":9,"i4":9,"i5":9,"i6":9,"i7":9,"i8":9,"i9":9,"i10":9,"i11":9,"i12":9,"i13":9};
var tabs = {65535:["t0","All Methods"],1:["t1","Static Methods"],8:["t4","Concrete Methods"]};
var altColor = "altColor";
var rowColor = "rowColor";
var tableTab = "tableTab";
var activeTableTab = "activeTableTab";
var pathtoroot = "../../";
var useModuleDirectories = false;
loadScripts(document, 'script');</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<header role="banner">
<nav role="navigation">
<div class="fixedNav">
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="topNav"><a id="navbar.top">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.top" title="Skip navigation links">Skip navigation links</a></div>
<a id="navbar.top.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../index.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../index-all.html">Index</a></li>
<li><a href="../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList" id="allclasses_navbar_top">
<li><a href="../../allclasses.html">All&nbsp;Classes</a></li>
</ul>
<ul class="navListSearch">
<li><label for="search">SEARCH:</label>
<input type="text" id="search" value="search" disabled="disabled">
<input type="reset" id="reset" value="reset" disabled="disabled">
</li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_top");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
<a id="skip.navbar.top">
<!--   -->
</a></div>
<!-- ========= END OF TOP NAVBAR ========= -->
</div>
<div class="navPadding">&nbsp;</div>
<script type="text/javascript"><!--
$('.navPadding').css('padding-top', $('.fixedNav').css("height"));
//-->
</script>
</nav>
</header>
<!-- ======== START OF CLASS DATA ======== -->
<main role="main">
<div class="header">
<div class="subTitle"><span class="packageLabelInType">Package</span>&nbsp;<a href="package-summary.html">generic.test</a></div>
<h2 title="Class TestUtils" class="title">Class TestUtils</h2>
</div>
<div class="contentContainer">
<ul class="inheritance">
<li>java.lang.Object</li>
<li>
<ul class="inheritance">
<li>generic.test.TestUtils</li>
</ul>
</li>
</ul>
<div class="description">
<ul class="blockList">
<li class="blockList">
<hr>
<pre>public class <span class="typeNameLabel">TestUtils</span>
extends java.lang.Object</pre>
<div class="block">Actually, not.  At least not soon...all the *TestCase classes now can
 be split apart into static-style utility methods, and instance-type
 test harness/scaffold methods, but they will need to live at their
 respective layer, not all here in Base.
 
 Future home of utility methods (many methods of TestCase can be put here).
 <P>
 A primary motivating factor for creating this class is to gain access to some of the myriad 
 functionality in TestCase without loading its static data.</div>
</li>
</ul>
</div>
<div class="summary">
<ul class="blockList">
<li class="blockList">
<!-- ========== METHOD SUMMARY =========== -->
<section role="region">
<ul class="blockList">
<li class="blockList"><a id="method.summary">
<!--   -->
</a>
<h3>Method Summary</h3>
<table class="memberSummary">
<caption><span id="t0" class="activeTableTab"><span>All Methods</span><span class="tabEnd">&nbsp;</span></span><span id="t1" class="tableTab"><span><a href="javascript:show(1);">Static Methods</a></span><span class="tabEnd">&nbsp;</span></span><span id="t4" class="tableTab"><span><a href="javascript:show(8);">Concrete Methods</a></span><span class="tabEnd">&nbsp;</span></span></caption>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colSecond" scope="col">Method</th>
<th class="colLast" scope="col">Description</th>
</tr>
<tr id="i0" class="altColor">
<td class="colFirst"><code>static java.lang.Object[]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#args(java.lang.Object...)">args</a></span>&#8203;(java.lang.Object...&nbsp;objects)</code></th>
<td class="colLast">
<div class="block">A convenience method that can be statically  imported to use with the class, allowing 
 you to avoid your own ugly manual array creation.</div>
</td>
</tr>
<tr id="i1" class="rowColor">
<td class="colFirst"><code>static java.lang.Class&lt;?&gt;[]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#argTypes(java.lang.Class...)">argTypes</a></span>&#8203;(java.lang.Class&lt;?&gt;...&nbsp;classes)</code></th>
<td class="colLast">
<div class="block">A convenience method that can be statically  imported to use with the class, allowing 
 you to avoid your own ugly manual array creation.</div>
</td>
</tr>
<tr id="i2" class="altColor">
<td class="colFirst"><code>static java.lang.String</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#createStackTraceForAllThreads()">createStackTraceForAllThreads</a></span>()</code></th>
<td class="colLast">
<div class="block">Returns a string which is a printout of a stack trace for each thread running in the
 current JVM</div>
</td>
</tr>
<tr id="i3" class="rowColor">
<td class="colFirst"><code>static java.util.List&lt;java.lang.Object&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getAllInstanceFields(java.lang.Object)">getAllInstanceFields</a></span>&#8203;(java.lang.Object&nbsp;ownerInstance)</code></th>
<td class="colLast">
<div class="block">Gets all fields of the given object.</div>
</td>
</tr>
<tr id="i4" class="altColor">
<td class="colFirst"><code>static java.lang.Object</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getInstanceField(java.lang.String,java.lang.Object)">getInstanceField</a></span>&#8203;(java.lang.String&nbsp;fieldName,
                java.lang.Object&nbsp;ownerInstance)</code></th>
<td class="colLast">
<div class="block">Gets the instance field by the given name on the given object 
 instance.</div>
</td>
</tr>
<tr id="i5" class="rowColor">
<td class="colFirst"><code>static &lt;T&gt;&nbsp;T</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getInstanceFieldByClassType(java.lang.Class,java.lang.Object)">getInstanceFieldByClassType</a></span>&#8203;(java.lang.Class&lt;T&gt;&nbsp;classType,
                           java.lang.Object&nbsp;ownerInstance)</code></th>
<td class="colLast">
<div class="block">Get the first field object contained within object ownerInstance which has the type classType.</div>
</td>
</tr>
<tr id="i6" class="altColor">
<td class="colFirst"><code>static java.lang.Object</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#invokeConstructor(java.lang.Class,java.lang.Class%5B%5D,java.lang.Object%5B%5D)">invokeConstructor</a></span>&#8203;(java.lang.Class&lt;?&gt;&nbsp;containingClass,
                 java.lang.Class&lt;?&gt;[]&nbsp;parameterTypes,
                 java.lang.Object[]&nbsp;args)</code></th>
<td class="colLast">
<div class="block">Uses reflection to execute the constructor for the given class with the given parameters.</div>
</td>
</tr>
<tr id="i7" class="rowColor">
<td class="colFirst"><code>static java.lang.Object</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#invokeInstanceMethod(java.lang.String,java.lang.Object)">invokeInstanceMethod</a></span>&#8203;(java.lang.String&nbsp;methodName,
                    java.lang.Object&nbsp;ownerInstance)</code></th>
<td class="colLast">
<div class="block">This method is just a "pass through" method for 
 <a href="#invokeInstanceMethod(java.lang.String,java.lang.Object,java.lang.Class%5B%5D,java.lang.Object%5B%5D)"><code>invokeInstanceMethod(String, Object, Class[], Object[])</code></a> so 
 that callers do not need to pass null to that method when the 
 underlying instance method does not have any parameters.</div>
</td>
</tr>
<tr id="i8" class="altColor">
<td class="colFirst"><code>static java.lang.Object</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#invokeInstanceMethod(java.lang.String,java.lang.Object,java.lang.Class%5B%5D,java.lang.Object%5B%5D)">invokeInstanceMethod</a></span>&#8203;(java.lang.String&nbsp;methodName,
                    java.lang.Object&nbsp;ownerInstance,
                    java.lang.Class&lt;?&gt;[]&nbsp;parameterTypes,
                    java.lang.Object[]&nbsp;args)</code></th>
<td class="colLast">
<div class="block">Uses reflection to execute the method denoted by the given method
 name.</div>
</td>
</tr>
<tr id="i9" class="rowColor">
<td class="colFirst"><code>static java.lang.Object</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#invokeInstanceMethod(java.lang.String,java.lang.Object,java.lang.Class,java.lang.Object)">invokeInstanceMethod</a></span>&#8203;(java.lang.String&nbsp;methodName,
                    java.lang.Object&nbsp;ownerInstance,
                    java.lang.Class&lt;?&gt;&nbsp;parameterType,
                    java.lang.Object&nbsp;arg)</code></th>
<td class="colLast">
<div class="block">Uses reflection to execute the method denoted by the given method
 name.</div>
</td>
</tr>
<tr id="i10" class="altColor">
<td class="colFirst"><code>static java.lang.Object</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#invokeInstanceMethod(java.lang.String,java.lang.Object,java.lang.Object...)">invokeInstanceMethod</a></span>&#8203;(java.lang.String&nbsp;methodName,
                    java.lang.Object&nbsp;ownerInstance,
                    java.lang.Object...&nbsp;args)</code></th>
<td class="colLast">
<div class="block">Uses reflection to execute the method denoted by the given method
 name.</div>
</td>
</tr>
<tr id="i11" class="rowColor">
<td class="colFirst"><code>static java.lang.Object</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#invokeInstanceMethod(java.lang.String,java.lang.Object,java.util.List,java.util.List)">invokeInstanceMethod</a></span>&#8203;(java.lang.String&nbsp;methodName,
                    java.lang.Object&nbsp;ownerInstance,
                    java.util.List&lt;java.lang.Class&lt;?&gt;&gt;&nbsp;parameterTypes,
                    java.util.List&lt;java.lang.Object&gt;&nbsp;args)</code></th>
<td class="colLast">
<div class="block">Uses reflection to execute the method denoted by the given method
 name.</div>
</td>
</tr>
<tr id="i12" class="altColor">
<td class="colFirst"><code>static java.lang.reflect.Field</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#locateFieldByTypeOnClass(java.lang.Class,java.lang.Class)">locateFieldByTypeOnClass</a></span>&#8203;(java.lang.Class&lt;?&gt;&nbsp;classType,
                        java.lang.Class&lt;?&gt;&nbsp;containingClass)</code></th>
<td class="colLast">
<div class="block">Get the first field specification contained within containingClass which has the type classType.</div>
</td>
</tr>
<tr id="i13" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#setInstanceField(java.lang.String,java.lang.Object,java.lang.Object)">setInstanceField</a></span>&#8203;(java.lang.String&nbsp;fieldName,
                java.lang.Object&nbsp;ownerInstance,
                java.lang.Object&nbsp;value)</code></th>
<td class="colLast">
<div class="block">Sets the instance field by the given name on the given object 
 instance.</div>
</td>
</tr>
</table>
<ul class="blockList">
<li class="blockList"><a id="methods.inherited.from.class.java.lang.Object">
<!--   -->
</a>
<h3>Methods inherited from class&nbsp;java.lang.Object</h3>
<code>clone, equals, finalize, getClass, hashCode, notify, notifyAll, toString, wait, wait, wait</code></li>
</ul>
</li>
</ul>
</section>
</li>
</ul>
</div>
<div class="details">
<ul class="blockList">
<li class="blockList">
<!-- ============ METHOD DETAIL ========== -->
<section role="region">
<ul class="blockList">
<li class="blockList"><a id="method.detail">
<!--   -->
</a>
<h3>Method Detail</h3>
<a id="createStackTraceForAllThreads()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>createStackTraceForAllThreads</h4>
<pre class="methodSignature">public static&nbsp;java.lang.String&nbsp;createStackTraceForAllThreads()</pre>
<div class="block">Returns a string which is a printout of a stack trace for each thread running in the
 current JVM</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the stack trace string</dd>
</dl>
</li>
</ul>
<a id="setInstanceField(java.lang.String,java.lang.Object,java.lang.Object)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setInstanceField</h4>
<pre class="methodSignature">public static&nbsp;void&nbsp;setInstanceField&#8203;(java.lang.String&nbsp;fieldName,
                                    java.lang.Object&nbsp;ownerInstance,
                                    java.lang.Object&nbsp;value)
                             throws java.lang.RuntimeException</pre>
<div class="block">Sets the instance field by the given name on the given object 
 instance.  
 <p>
 Note: if the field is static, then the <code>ownerInstance</code> field 
 can be the class of the object that contains the variable.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>fieldName</code> - The name of the field to retrieve.</dd>
<dd><code>ownerInstance</code> - The object instance from which to get the 
         variable instance.</dd>
<dd><code>value</code> - The value to use when setting the given field</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.lang.RuntimeException</code> - if there is a problem accessing the field
         using reflection.  A RuntimeException is used so that calling
         tests can avoid using a try/catch block, but will still fail
         when an error is encountered.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><code>Field.set(Object, Object)</code></dd>
</dl>
</li>
</ul>
<a id="getInstanceField(java.lang.String,java.lang.Object)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getInstanceField</h4>
<pre class="methodSignature">public static&nbsp;java.lang.Object&nbsp;getInstanceField&#8203;(java.lang.String&nbsp;fieldName,
                                                java.lang.Object&nbsp;ownerInstance)
                                         throws java.lang.RuntimeException</pre>
<div class="block">Gets the instance field by the given name on the given object 
 instance.  The value is a primitive wrapper if it is a primitive type.
 <p>
 Note: if the field is static, then the <code>ownerInstance</code> field 
 can be the class of the object that contains the variable.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>fieldName</code> - The name of the field to retrieve.</dd>
<dd><code>ownerInstance</code> - The object instance from which to get the 
         variable instance.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The field instance.</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.lang.RuntimeException</code> - if there is a problem accessing the field
         using reflection.  A RuntimeException is used so that calling
         tests can avoid using a try/catch block, but will still fail
         when an error is encountered.</dd>
<dt><span class="simpleTagLabel">Since:</span></dt>
<dd>Tracker Id 267</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><code>Field.get(java.lang.Object)</code></dd>
</dl>
</li>
</ul>
<a id="getAllInstanceFields(java.lang.Object)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getAllInstanceFields</h4>
<pre class="methodSignature">public static&nbsp;java.util.List&lt;java.lang.Object&gt;&nbsp;getAllInstanceFields&#8203;(java.lang.Object&nbsp;ownerInstance)</pre>
<div class="block">Gets all fields of the given object.  Only objects on the immediate instance are 
 returned.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>ownerInstance</code> - the object from which to get fields</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the fields</dd>
</dl>
</li>
</ul>
<a id="invokeInstanceMethod(java.lang.String,java.lang.Object,java.lang.Class[],java.lang.Object[])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>invokeInstanceMethod</h4>
<pre class="methodSignature">public static&nbsp;java.lang.Object&nbsp;invokeInstanceMethod&#8203;(java.lang.String&nbsp;methodName,
                                                    java.lang.Object&nbsp;ownerInstance,
                                                    java.lang.Class&lt;?&gt;[]&nbsp;parameterTypes,
                                                    java.lang.Object[]&nbsp;args)
                                             throws java.lang.RuntimeException</pre>
<div class="block">Uses reflection to execute the method denoted by the given method
 name.  If any value is returned from the method execution, then it 
 will be returned from this method.  Otherwise, <code>null</code> is returned.
 <p>
 Note: if the method is static, then the <code>ownerInstance</code> field 
 can be the class of the object that contains the method.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>methodName</code> - The name of the method to execute.</dd>
<dd><code>ownerInstance</code> - The object instance of which the method will be
        executed.</dd>
<dd><code>parameterTypes</code> - The parameter <b>types</b> that the method takes.</dd>
<dd><code>args</code> - The parameter values that should be passed to the method.
        This value can be null or zero length if there are no parameters
        to pass</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The return value as returned from executing the method.</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.lang.RuntimeException</code> - if there is a problem accessing the field
         using reflection.  A RuntimeException is used so that calling
         tests can avoid using a try/catch block, but will still fail
         when an error is encountered.</dd>
<dt><span class="simpleTagLabel">Since:</span></dt>
<dd>Tracker Id 267</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><code>Method.invoke(java.lang.Object, java.lang.Object[])</code></dd>
</dl>
</li>
</ul>
<a id="invokeInstanceMethod(java.lang.String,java.lang.Object,java.util.List,java.util.List)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>invokeInstanceMethod</h4>
<pre class="methodSignature">public static&nbsp;java.lang.Object&nbsp;invokeInstanceMethod&#8203;(java.lang.String&nbsp;methodName,
                                                    java.lang.Object&nbsp;ownerInstance,
                                                    java.util.List&lt;java.lang.Class&lt;?&gt;&gt;&nbsp;parameterTypes,
                                                    java.util.List&lt;java.lang.Object&gt;&nbsp;args)
                                             throws java.lang.RuntimeException</pre>
<div class="block">Uses reflection to execute the method denoted by the given method
 name.  If any value is returned from the method execution, then it 
 will be returned from this method.  Otherwise, <code>null</code> is returned.
 <p>
 Note: if the method is static, then the <code>ownerInstance</code> field 
 can be the class of the object that contains the method.
 
 <P>This method is just a convenience for calling 
 <a href="#invokeInstanceMethod(java.lang.String,java.lang.Object,java.lang.Class%5B%5D,java.lang.Object%5B%5D)"><code>invokeInstanceMethod(String, Object, Class[], Object[])</code></a>.  As the following 
 example shows, this method's uses is a bit cleaner:
 <PRE>
        // The call below is equivalent to calling: <CODE> System.out.println("Hi")
        invokeInstanceMethod("println", System.out, Arrays.asList(String.class), Arrays.asList("Hi"));
        </CODE>
 </PRE></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>methodName</code> - The name of the method to execute.</dd>
<dd><code>ownerInstance</code> - The object instance of which the method will be
        executed.</dd>
<dd><code>parameterTypes</code> - The parameter <b>types</b> that the method takes.</dd>
<dd><code>args</code> - The parameter values that should be passed to the method.
        This value can be null or zero length if there are no parameters
        to pass</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The return value as returned from executing the method.</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.lang.RuntimeException</code> - if there is a problem accessing the field
         using reflection.  A RuntimeException is used so that calling
         tests can avoid using a try/catch block, but will still fail
         when an error is encountered.</dd>
</dl>
</li>
</ul>
<a id="invokeInstanceMethod(java.lang.String,java.lang.Object,java.lang.Class,java.lang.Object)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>invokeInstanceMethod</h4>
<pre class="methodSignature">public static&nbsp;java.lang.Object&nbsp;invokeInstanceMethod&#8203;(java.lang.String&nbsp;methodName,
                                                    java.lang.Object&nbsp;ownerInstance,
                                                    java.lang.Class&lt;?&gt;&nbsp;parameterType,
                                                    java.lang.Object&nbsp;arg)
                                             throws java.lang.RuntimeException</pre>
<div class="block">Uses reflection to execute the method denoted by the given method
 name.  If any value is returned from the method execution, then it 
 will be returned from this method.  Otherwise, <code>null</code> is returned.
 <p>
 Note: if the method is static, then the <code>ownerInstance</code> field 
 can be the class of the object that contains the method.
 
 <P>If the method you are calling takes no parameters, then call 
 <a href="#invokeInstanceMethod(java.lang.String,java.lang.Object)"><code>invokeInstanceMethod(String, Object)</code></a> instead.
 
 <P>This method is just a convenience for calling 
 <a href="#invokeInstanceMethod(java.lang.String,java.lang.Object,java.lang.Class%5B%5D,java.lang.Object%5B%5D)"><code>invokeInstanceMethod(String, Object, Class[], Object[])</code></a> when the method only
 takes a single parameter, so that you don't have the ugliness of creating arrays as the
 parameters for this method.
 
 <P>As an example:
 <PRE>
        // The call below is equivalent to calling: <CODE> System.out.println("Hi")
        invokeInstanceMethod("println", System.out, String.class, "Hi");
        </CODE>
 </PRE></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>methodName</code> - The name of the method to execute.</dd>
<dd><code>ownerInstance</code> - The object instance of which the method will be
        executed.</dd>
<dd><code>parameterType</code> - The parameter types that the method takes.</dd>
<dd><code>arg</code> - The parameter value that should be passed to the method.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The return value as returned from executing the method.</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.lang.RuntimeException</code> - if there is a problem accessing the field
         using reflection.  A RuntimeException is used so that calling
         tests can avoid using a try/catch block, but will still fail
         when an error is encountered.</dd>
</dl>
</li>
</ul>
<a id="invokeInstanceMethod(java.lang.String,java.lang.Object,java.lang.Object...)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>invokeInstanceMethod</h4>
<pre class="methodSignature">public static&nbsp;java.lang.Object&nbsp;invokeInstanceMethod&#8203;(java.lang.String&nbsp;methodName,
                                                    java.lang.Object&nbsp;ownerInstance,
                                                    java.lang.Object...&nbsp;args)
                                             throws java.lang.RuntimeException</pre>
<div class="block">Uses reflection to execute the method denoted by the given method
 name.  If any value is returned from the method execution, then it 
 will be returned from this method.  Otherwise, <code>null</code> is returned.
 <p>
 Note: if the method is static, then the <code>ownerInstance</code> field 
 can be the class of the object that contains the method.
 
 <P><B>Warning: The exact class of each <CODE>arg</CODE> will be used as the class type
 of the parameter for the method being called.  If the method you are calling takes 
 parameters that do not match exactly the class of the args you wish to use, then 
 call <a href="#invokeInstanceMethod(java.lang.String,java.lang.Object,java.util.List,java.util.List)"><code>invokeInstanceMethod(String, Object, List, List)</code></a> instead so that you 
 can specify the parameter types explicitly.
 </B>
 
 <P>If the method you are calling takes no parameters, then call 
 <a href="#invokeInstanceMethod(java.lang.String,java.lang.Object)"><code>invokeInstanceMethod(String, Object)</code></a> instead.
 
 <P>This method is just a convenience for calling 
 <a href="#invokeInstanceMethod(java.lang.String,java.lang.Object,java.lang.Class%5B%5D,java.lang.Object%5B%5D)"><code>invokeInstanceMethod(String, Object, Class[], Object[])</code></a> when the method only
 takes a single parameter, so that you don't have the ugliness of creating arrays as the
 parameters for this method.
 
 <P>As an example:
 <PRE>
        // The call below is equivalent to calling: <CODE> System.out.println("Hi")
        invokeInstanceMethod("println", System.out, "Hi");
 
        // This call is equivalent to the one above
        invokeInstanceMethod("println", System.out, Arrays.asList(String.class), Arrays.asList("Hi"));
        
        </CODE>
 </PRE></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>methodName</code> - The name of the method to execute.</dd>
<dd><code>ownerInstance</code> - The object instance of which the method will be
        executed.</dd>
<dd><code>args</code> - The parameter value that should be passed to the method.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The return value as returned from executing the method.</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.lang.RuntimeException</code> - if there is a problem accessing the field
         using reflection.  A RuntimeException is used so that calling
         tests can avoid using a try/catch block, but will still fail
         when an error is encountered.</dd>
</dl>
</li>
</ul>
<a id="invokeInstanceMethod(java.lang.String,java.lang.Object)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>invokeInstanceMethod</h4>
<pre class="methodSignature">public static&nbsp;java.lang.Object&nbsp;invokeInstanceMethod&#8203;(java.lang.String&nbsp;methodName,
                                                    java.lang.Object&nbsp;ownerInstance)
                                             throws java.lang.RuntimeException</pre>
<div class="block">This method is just a "pass through" method for 
 <a href="#invokeInstanceMethod(java.lang.String,java.lang.Object,java.lang.Class%5B%5D,java.lang.Object%5B%5D)"><code>invokeInstanceMethod(String, Object, Class[], Object[])</code></a> so 
 that callers do not need to pass null to that method when the 
 underlying instance method does not have any parameters.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>methodName</code> - The name of the method to execute.</dd>
<dd><code>ownerInstance</code> - The object instance of which the method will be
        executed.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The return value as returned from executing the method.</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.lang.RuntimeException</code> - if there is a problem accessing the field
         using reflection.  A RuntimeException is used so that calling
         tests can avoid using a try/catch block, but will still fail
         when an error is encountered.</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><code>Method.invoke(java.lang.Object, java.lang.Object[])</code>, 
<a href="#invokeInstanceMethod(java.lang.String,java.lang.Object,java.lang.Class%5B%5D,java.lang.Object%5B%5D)"><code>invokeInstanceMethod(String, Object, Class[], Object[])</code></a></dd>
</dl>
</li>
</ul>
<a id="invokeConstructor(java.lang.Class,java.lang.Class[],java.lang.Object[])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>invokeConstructor</h4>
<pre class="methodSignature">public static&nbsp;java.lang.Object&nbsp;invokeConstructor&#8203;(java.lang.Class&lt;?&gt;&nbsp;containingClass,
                                                 java.lang.Class&lt;?&gt;[]&nbsp;parameterTypes,
                                                 java.lang.Object[]&nbsp;args)
                                          throws java.lang.RuntimeException</pre>
<div class="block">Uses reflection to execute the constructor for the given class with the given parameters.
 The new instance of the given class will be returned.
 <p></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>containingClass</code> - The class that contains the desired constructor.</dd>
<dd><code>parameterTypes</code> - The parameter <b>types</b> that the constructor takes.
        This value can be null or zero length if there are no parameters
        to pass</dd>
<dd><code>args</code> - The parameter values that should be passed to the constructor.
        This value can be null or zero length if there are no parameters
        to pass</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The new class instance</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.lang.RuntimeException</code> - if there is a problem accessing the constructor
         using reflection.  A RuntimeException is used so that calling
         tests can avoid using a try/catch block, but will still fail
         when an error is encountered.</dd>
</dl>
</li>
</ul>
<a id="argTypes(java.lang.Class...)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>argTypes</h4>
<pre class="methodSignature">public static&nbsp;java.lang.Class&lt;?&gt;[]&nbsp;argTypes&#8203;(java.lang.Class&lt;?&gt;...&nbsp;classes)</pre>
<div class="block">A convenience method that can be statically  imported to use with the class, allowing 
 you to avoid your own ugly manual array creation.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>classes</code> - the classes</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the classes array</dd>
</dl>
</li>
</ul>
<a id="args(java.lang.Object...)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>args</h4>
<pre class="methodSignature">public static&nbsp;java.lang.Object[]&nbsp;args&#8203;(java.lang.Object...&nbsp;objects)</pre>
<div class="block">A convenience method that can be statically  imported to use with the class, allowing 
 you to avoid your own ugly manual array creation.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>objects</code> - the objects</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the objects array</dd>
</dl>
</li>
</ul>
<a id="getInstanceFieldByClassType(java.lang.Class,java.lang.Object)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getInstanceFieldByClassType</h4>
<pre class="methodSignature">public static&nbsp;&lt;T&gt;&nbsp;T&nbsp;getInstanceFieldByClassType&#8203;(java.lang.Class&lt;T&gt;&nbsp;classType,
                                                java.lang.Object&nbsp;ownerInstance)</pre>
<div class="block">Get the first field object contained within object ownerInstance which has the type classType.
 This method is only really useful if it is known that only a single field of 
 classType exists within the ownerInstance.</div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>T</code> - the type</dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>classType</code> - the class type of the desired field</dd>
<dd><code>ownerInstance</code> - the object instance that owns the field</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>field object of type classType or null</dd>
</dl>
</li>
</ul>
<a id="locateFieldByTypeOnClass(java.lang.Class,java.lang.Class)">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>locateFieldByTypeOnClass</h4>
<pre class="methodSignature">public static&nbsp;java.lang.reflect.Field&nbsp;locateFieldByTypeOnClass&#8203;(java.lang.Class&lt;?&gt;&nbsp;classType,
                                                               java.lang.Class&lt;?&gt;&nbsp;containingClass)</pre>
<div class="block">Get the first field specification contained within containingClass which has the type classType.
 This method is only really useful if it is known that only a single field of 
 classType exists within the containingClass hierarchy.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>classType</code> - the class</dd>
<dd><code>containingClass</code> - the class that contains a field of the given type</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>field which corresponds to type classType or null</dd>
</dl>
</li>
</ul>
</li>
</ul>
</section>
</li>
</ul>
</div>
</div>
</main>
<!-- ========= END OF CLASS DATA ========= -->
<footer role="contentinfo">
<nav role="navigation">
<!-- ======= START OF BOTTOM NAVBAR ====== -->
<div class="bottomNav"><a id="navbar.bottom">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.bottom" title="Skip navigation links">Skip navigation links</a></div>
<a id="navbar.bottom.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../index.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../index-all.html">Index</a></li>
<li><a href="../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList" id="allclasses_navbar_bottom">
<li><a href="../../allclasses.html">All&nbsp;Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_bottom");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
<a id="skip.navbar.bottom">
<!--   -->
</a></div>
<!-- ======== END OF BOTTOM NAVBAR ======= -->
</nav>
</footer>
</body>
</html>
